{
  "dex": {
    "name": "Decentralized Exchanges",
    "explanation": "DA requirements for DEXs are driven by order book updates, trade execution speed, liquidity pool rebalancing, and market dynamics. High-frequency trading, flash crashes, and large market movements can cause significant DA spikes.",
    "metrics": [
      {
        "name": "Order Book Management",
        "ongoing": 3267500,
        "volatility": 26000000,
        "subMetrics": [
          {
            "name": "Order Placement Rate",
            "ongoing": 375000,
            "volatility": 1875000,
            "ongoingExample": "Across popular trading pairs the market sees 1,500,000 new limit orders per second, requiring frequent order book updates.\nEach order placement is 250 bytes, accounting for metadata, signatures, and potential cross-chain information.",
            "volatilityExample": "During a market crash, order placement rate spikes to 7,500,000 per second, causing a surge in DA demand.",
            "assumptions": "Measures the rate at which new orders are placed on the order book.\nAssumes 100M active agents trading across multiple pairs, with varying levels of trading frequency and sophistication.\nScales superlinearly with the number of agents due to increased market complexity and cross-chain interactions."
          },
          {
            "name": "Order Cancellation Rate",
            "ongoing": 80000,
            "volatility": 4000000,
            "ongoingExample": "Trading agents cancel about 400,000 orders per second as part of regular strategy adjustments.\nEach order cancellation is 200 bytes.",
            "volatilityExample": "A false rumor causes panic, leading to 20,000,000 order cancellations per second.",
            "assumptions": "Measures the rate at which orders are canceled.\nAssumes a mix of manual traders and basic trading bots among the 100M agents, with moderate order adjustment frequencies.\nScales linearly with the number of agents, but at a slightly lower rate for a large number of agents."
          },
          {
            "name": "Order Book Depth",
            "ongoing": 1125000,
            "volatility": 11250000,
            "ongoingExample": "The order book maintains 1,500,000 updates per second, requiring constant updates.\nEach order book update is 750 bytes, accounting for more complex order book structures in a multi-chain environment.",
            "volatilityExample": "Market makers add liquidity, expanding the order book to 15,000,000 updates per second.",
            "assumptions": "Represents the number of orders at various price levels in the order book.\nAssumes moderate liquidity across popular trading pairs, with a few dedicated market makers among the 100M agents.\nScales exponentially due to increasing complexity and interactions across multiple chains."
          },
          {
            "name": "Order Modification Rate",
            "ongoing": 87500,
            "volatility": 875000,
            "ongoingExample": "Traders modify about 350,000 orders per second to adjust their positions.\nEach order modification is 250 bytes, accounting for additional metadata and cross-chain information.",
            "volatilityExample": "During high volatility, order modifications spike to 3,500,000 per second.",
            "assumptions": "Measures the rate at which existing orders are modified (e.g., changing price or quantity).\nAssumes occasional order modifications by a subset of the 100M agents.\nScales linearly with the number of agents, with a slight increase in rate for a large number of agents."
          },
          {
            "name": "Order Matching Rate",
            "ongoing": 1600000,
            "volatility": 8000000,
            "ongoingExample": "The exchange matches 4,000,000 orders per second during normal trading.\nEach order match is 400 bytes, accounting for more complex matching scenarios in a multi-chain environment.",
            "volatilityExample": "A sudden market movement leads to 20,000,000 order matches per second.",
            "assumptions": "Measures the frequency at which orders are matched and removed from the order book.\nAssumes regular order matching activity suitable for 100M agents.\nScales exponentially due to higher frequency of matches as the number of agents increases."
          }
        ],
        "explanation": "Order book management DA increases due to:\n• Higher frequency of order placements and cancellations\n• Deeper order books requiring more data storage and updates\n• Need for real-time synchronization across all nodes\n• Increased complexity in maintaining order book integrity during high volatility"
      },
      {
        "name": "Trade Execution",
        "ongoing": 300000,
        "volatility": 6400000,
        "subMetrics": [
          {
            "name": "Transaction Rate",
            "ongoing": 140000,
            "volatility": 4900000,
            "ongoingExample": "The exchange processes 400,000 trades per second during normal market conditions.\nEach trade transaction is 350 bytes, accounting for additional metadata, signatures, and potential cross-chain information.",
            "volatilityExample": "A major news event causes trading volume to spike to 14,000,000 trades per second.",
            "assumptions": "Measures the number of trades executed per second.\nAssumes standard transaction processing capabilities suitable for 100M agents, with occasional spikes in trading activity.\nScales exponentially with the number of agents, but with a slightly reduced rate for a large number of agents."
          },
          {
            "name": "Slippage Monitoring",
            "ongoing": 15000,
            "volatility": 600000,
            "ongoingExample": "Slippage is calculated for 100,000 trades per second for active trading pairs.\nEach slippage data point is 150 bytes, accounting for detailed slippage information across multiple chains.",
            "volatilityExample": "High volatility requires slippage calculations for 4,000,000 trades per second to protect traders.",
            "assumptions": "Measures the difference between the expected and actual trade prices.\nAssumes basic slippage protection mechanisms suitable for the trading volume generated by 100M agents.\nScales superlinearly with the number of trades, reflecting increased market complexity without full exponential growth."
          },
          {
            "name": "Trade Confirmation Time",
            "ongoing": 35000,
            "volatility": 700000,
            "ongoingExample": "175,000 trade confirmations are processed per second under normal conditions.\nEach trade confirmation is 200 bytes, accounting for additional confirmation details in a multi-chain environment.",
            "volatilityExample": "During peak trading, confirmation rate increases to 3,500,000 per second due to network congestion.",
            "assumptions": "Measures the time it takes for a trade to be confirmed.\nAssumes regular confirmation processes suitable for 100M agents.\nScales superlinearly with the number of trades, reflecting increased complexity without full exponential growth."
          },
          {
            "name": "Trade Settlement Rate",
            "ongoing": 110000,
            "volatility": 2200000,
            "ongoingExample": "440,000 trades are settled per second in regular conditions.\nEach trade settlement is 250 bytes, accounting for more complex settlement processes in a multi-chain environment.",
            "volatilityExample": "High trading volume requires settlement of 8,800,000 trades per second to prevent backlogs.",
            "assumptions": "Measures the rate at which trades are settled and final.\nAssumes periodic settlement processes suitable for the trading volume of 100M agents.\nScales exponentially with the number of trades, but with a slightly reduced rate for a large number of agents."
          }
        ],
        "explanation": "Trade execution DA spikes due to:\n• Dramatic increase in transaction volume during volatile periods\n• Larger trade sizes requiring more data to process and verify\n• More frequent and complex slippage calculations\n• Need for faster block creation and propagation to handle increased load"
      },
      {
        "name": "Liquidity Pool Updates",
        "ongoing": 105500,
        "volatility": 6552000,
        "subMetrics": [
          {
            "name": "Pool Rebalancing",
            "ongoing": 12000,
            "volatility": 1200000,
            "ongoingExample": "Liquidity pools rebalance 20,000 times per second to maintain target ratios.\nEach pool rebalancing action is 600 bytes, accounting for more complex rebalancing data in a multi-chain environment.",
            "volatilityExample": "Rapid price changes force pool rebalancing 2,000,000 times per second.",
            "assumptions": "Measures the frequency of rebalancing the liquidity pool.\nAssumes moderate-sized liquidity pools suitable for the trading volume from 100M agents, with periodic rebalancing to maintain ratios.\nScales superlinearly with the number of agents due to increased complexity and frequency of rebalancing in a multi-chain environment."
          },
          {
            "name": "Liquidity Provider Actions",
            "ongoing": 30000,
            "volatility": 300000,
            "ongoingExample": "150,000 liquidity providers adjust their positions per second.\nEach liquidity provider action (add/remove liquidity) is 200 bytes.",
            "volatilityExample": "A yield farming opportunity causes 1,500,000 LP adjustments per second.",
            "assumptions": "Tracks actions by liquidity providers such as adding or removing liquidity.\nAssumes a small portion of the 100M agents are active liquidity providers, with occasional position adjustments based on market conditions.\nScales superlinearly with the number of agents due to increased complexity and frequency of liquidity provision across multiple chains."
          },
          {
            "name": "Automated Market Making",
            "ongoing": 14000,
            "volatility": 1400000,
            "ongoingExample": "AMM curves are updated 40,000 times per second under normal conditions.\nEach automated market making action is 350 bytes, accounting for more complex AMM operations in a multi-chain environment.",
            "volatilityExample": "Extreme volatility requires 4,000,000 AMM curve updates per second.",
            "assumptions": "Measures the activity of the automated market maker algorithm.\nAssumes basic AMM algorithms suitable for handling the trading volume and market dynamics created by 100M agents.\nScales exponentially with the number of agents due to the increased complexity of balancing liquidity across multiple chains and pools."
          },
          {
            "name": "Fee Calculation and Distribution",
            "ongoing": 12000,
            "volatility": 600000,
            "ongoingExample": "Fees are calculated and distributed 40,000 times per second.\nEach fee calculation and distribution action is 300 bytes, accounting for more complex fee structures in a multi-chain environment.",
            "volatilityExample": "High trading volume requires 2,000,000 fee calculations and distributions per second.",
            "assumptions": "Measures the frequency and size of fee calculations and distributions to liquidity providers.\nAssumes basic fee calculation and distribution mechanisms suitable for 100M agents.\nScales exponentially with the number of agents due to the increased complexity of fee structures and distribution across multiple chains."
          },
          {
            "name": "Price Updates",
            "ongoing": 37500,
            "volatility": 1875000,
            "ongoingExample": "Asset prices are updated 250,000 times per second.\nEach price update is 150 bytes.",
            "volatilityExample": "Rapid market movements require 12,500,000 price updates per second.",
            "assumptions": "Measures the frequency and size of updates to pool prices based on market conditions.\nAssumes regular price update mechanisms suitable for 100M agents.\nScales exponentially with the number of agents due to the increased frequency and complexity of price updates required in a multi-chain environment."
          }
        ],
        "explanation": "Liquidity pool updates require more DA due to:\n• Frequent rebalancing of pools to maintain desired ratios\n• Increased liquidity provider activities (adding/removing liquidity)\n• More complex and frequent automated market making calculations\n• Need for real-time updates of pool states across the network"
      },
      {
        "name": "Price Oracle Management",
        "ongoing": 235000,
        "volatility": 4752000,
        "subMetrics": [
          {
            "name": "Oracle Data Submissions",
            "ongoing": 100000,
            "volatility": 2000000,
            "ongoingExample": "Price oracles submit 500,000 updates per second for major trading pairs.\nEach oracle data submission is 200 bytes, including asset identifier, price, timestamp, and provider signature.",
            "volatilityExample": "During high volatility, oracles submit 10,000,000 updates per second.",
            "assumptions": "Measures the frequency and size of price data submissions from oracle providers.\nAssumes regular oracle data submissions suitable for 100M agents.\nScales superlinearly due to increased complexity and the need for frequent updates as more agents participate, with optimizations at scale."
          },
          {
            "name": "Oracle Provider Reputation Updates",
            "ongoing": 15000,
            "volatility": 150000,
            "ongoingExample": "Oracle provider reputations are updated 50,000 times per second based on accuracy.\nEach reputation update is 300 bytes, including provider identifier, new reputation score, and supporting data.",
            "volatilityExample": "A potential oracle attack leads to 500,000 reputation updates per second.",
            "assumptions": "Measures the frequency of updates to the reputation scores of oracle providers.\nAssumes basic reputation management for oracle providers suitable for 100M agents.\nScales superlinearly as the number of providers increases, but with optimizations at scale."
          },
          {
            "name": "Consensus Mechanism Updates",
            "ongoing": 5000,
            "volatility": 500000,
            "ongoingExample": "The oracle consensus mechanism is updated 10 times per second.\nEach consensus mechanism update is 500 bytes, including new parameters, justification, and activation timestamp.",
            "volatilityExample": "A critical vulnerability requires 1,000 consensus updates per second.",
            "assumptions": "Measures the frequency of updates to the consensus mechanism for aggregating oracle data.\nAssumes infrequent consensus mechanism updates suitable for 100M agents.\nScales logarithmically as the system becomes more stable with increased scale."
          },
          {
            "name": "Cross-Chain Price Synchronization",
            "ongoing": 115000,
            "volatility": 2300000,
            "ongoingExample": "Cross-chain price data is synchronized 287,500 times per second.\nEach synchronization event is 400 bytes, including price data for multiple assets, chain identifiers, and synchronization metadata.",
            "volatilityExample": "High cross-chain trading activity requires 5,750,000 synchronizations per second.",
            "assumptions": "Measures the frequency of synchronization events to ensure price consistency across chains.\nAssumes regular cross-chain price synchronization suitable for 100M agents.\nScales superlinearly as the number of interconnected chains increases, but with optimizations at scale."
          }
        ],
        "explanation": "Price oracle management DA requirements increase due to:\n• More frequent and precise oracle price updates\n• Increased complexity in managing oracle provider reputations\n• Need for consistent consensus across multiple chains\n• Challenges in maintaining price consistency across interconnected networks"
      }
    ]
  },
  "lendingBorrowing": {
    "name": "Lending and Borrowing",
    "explanation": "DA requirements for lending and borrowing protocols are driven by interest rate updates, collateral value fluctuations, and loan position changes. Market volatility and large-scale user actions can lead to sudden spikes in DA needs.",
    "metrics": [
      {
        "name": "Interest Rate Management",
        "ongoing": 28000,
        "volatility": 1064000,
        "subMetrics": [
          {
            "name": "Rate Calculation Frequency",
            "ongoing": 5000,
            "volatility": 100000,
            "ongoingExample": "Interest rates are recalculated 20,000 times per second based on utilization rates.\nEach rate calculation update is 250 bytes, accounting for more complex calculations involving multiple assets and chains.",
            "volatilityExample": "During high volatility, rates are updated 400,000 times per second to reflect rapid market changes.",
            "assumptions": "Measures how often interest rates are recalculated.\nAssumes a lending pool with moderate activity from 100M agents, requiring periodic rate adjustments.\nScales superlinearly with the number of agents due to increased complexity and frequency of calculations in a multi-asset, multi-chain environment."
          },
          {
            "name": "Market Data Integration",
            "ongoing": 15000,
            "volatility": 750000,
            "ongoingExample": "External price feeds are queried 25,000 times per second to adjust interest rates.\nEach market data update is 600 bytes, accounting for more comprehensive market data across multiple assets and chains.",
            "volatilityExample": "Price feeds are queried 1,250,000 times per second during market turbulence.",
            "assumptions": "Measures the frequency and size of market data updates integrated into the system.\nAssumes integration with a few key price oracles, suitable for the scale of 100M agents.\nScales superlinearly with the number of agents due to increased complexity and volume of market data across multiple assets and chains."
          },
          {
            "name": "User Notification System",
            "ongoing": 8000,
            "volatility": 80000,
            "ongoingExample": "Users receive 80,000 updates per second on their loan interest rates.\nEach user notification remains at 100 bytes, as the basic structure of notifications doesn't change significantly.",
            "volatilityExample": "Real-time notifications are sent 800,000 times per second for every rate change during volatile periods.",
            "assumptions": "Measures the frequency and size of notifications sent to users regarding interest rate changes.\nAssumes a basic notification system capable of handling updates for 100M users.\nScales superlinearly with the number of agents due to the increased number of users who need to be notified, but with optimizations for large-scale operations."
          }
        ],
        "explanation": "Interest rate management DA increases due to:\n• More frequent rate recalculations in volatile markets\n• Integration of real-time market data from multiple sources\n• Increased user notifications about rate changes\n• Need for rapid propagation of new rates across the network"
      },
      {
        "name": "Collateral Management",
        "ongoing": 443500,
        "volatility": 3062500,
        "subMetrics": [
          {
            "name": "Collateral Value Updates",
            "ongoing": 17000,
            "volatility": 170000,
            "ongoingExample": "Collateral values are updated 20,000 times per second under normal conditions.\nEach collateral value update is 350 bytes, accounting for more complex updates involving multiple assets and chains.",
            "volatilityExample": "During market crashes, collateral values are updated 200,000 times per second.",
            "assumptions": "Measures the frequency of updates to collateral values.\nAssumes a moderate range of collateral types used by 100M agents, requiring regular value updates.\nScales superlinearly with the number of agents due to increased complexity and frequency of updates in a multi-asset, multi-chain environment."
          },
          {
            "name": "Liquidation Monitoring",
            "ongoing": 11250,
            "volatility": 112500,
            "ongoingExample": "Liquidation thresholds are checked 25,000 times per second for all positions.\nEach liquidation monitoring update is 450 bytes, accounting for more comprehensive monitoring across multiple assets and chains.",
            "volatilityExample": "Continuous real-time monitoring results in 250,000 checks per second of all positions near liquidation thresholds.",
            "assumptions": "Measures the frequency of monitoring for potential liquidations.\nAssumes a liquidation engine capable of monitoring positions for 100M users with varying collateral ratios.\nScales superlinearly with the number of agents due to increased complexity and volume of monitoring across multiple assets and chains."
          },
          {
            "name": "Collateral Withdrawal Requests",
            "ongoing": 6000,
            "volatility": 30000,
            "ongoingExample": "Users perform 15,000 collateral withdrawals per second.\nEach withdrawal request is 400 bytes, as the basic structure of requests doesn't change significantly.",
            "volatilityExample": "Surge in withdrawal requests results in 75,000 requests per second as users seek to reduce exposure during market stress.",
            "assumptions": "Measures the frequency of requests to withdraw collateral.\nAssumes occasional collateral withdrawals by a subset of the 100M users, with increased activity during market stress.\nScales superlinearly with the number of agents due to increased complexity of cross-chain operations and enhanced security measures."
          },
          {
            "name": "Collateral Health Monitoring",
            "ongoing": 409250,
            "volatility": 2750000,
            "ongoingExample": "Collateral health is monitored 1,000,000 times per second for all active positions.",
            "volatilityExample": "During market volatility, collateral health is monitored 5,000,000 times per second.",
            "assumptions": "Measures the continuous monitoring of the health/status of collateral beyond just value updates.\nAssumes regular health checks for collateral owned by 100M users, with capacity for more frequent updates when needed.\nEach health monitoring update is 350 bytes, accounting for more comprehensive health monitoring.\nScales superlinearly as the number of agents and the complexity of monitoring increases, but with optimizations at scale."
          }
        ],
        "explanation": "Collateral management DA spikes due to:\n• Rapid and frequent updates of collateral asset prices\n• Increased liquidation events requiring immediate action\n• Higher frequency of collateral swaps and adjustments\n• Need for real-time risk assessment of collateralized positions"
      },
      {
        "name": "Loan Position Tracking",
        "ongoing": 24600,
        "volatility": 691200,
        "subMetrics": [
          {
            "name": "Position Health Calculation",
            "ongoing": 6000,
            "volatility": 90000,
            "ongoingExample": "Loan health is recalculated 20,000 times per second for all active positions.\nEach position health calculation is 300 bytes, accounting for more complex calculations involving multiple assets and chains.",
            "volatilityExample": "Health scores are updated 300,000 times per second during high volatility.",
            "assumptions": "Measures the frequency of calculating the health of loan positions.\nAssumes regular health calculations for loans held by 100M users, with varying loan sizes and collateral types.\nScales superlinearly with the number of agents due to increased complexity and frequency of calculations in a multi-asset, multi-chain environment."
          },
          {
            "name": "Loan Origination and Closure",
            "ongoing": 17500,
            "volatility": 455000,
            "ongoingExample": "New loans and repayments are processed at a rate of 25,000 per second.\nEach loan origination or closure operation is 700 bytes, accounting for more comprehensive processes across multiple assets and chains.",
            "volatilityExample": "Surge in new loans and emergency closures during market events leads to 650,000 processes per second.",
            "assumptions": "Measures the frequency of loan originations and closures.\nAssumes moderate loan origination and closure activity among 100M users, with occasional spikes.\nScales superlinearly with the number of agents due to increased complexity of cross-chain operations and enhanced security measures."
          },
          {
            "name": "Historical Data Management",
            "ongoing": 1100,
            "volatility": 146200,
            "ongoingExample": "Loan history is compressed and archived 2,000 times per second.\nEach historical data management operation is 800 bytes, accounting for more comprehensive data management across multiple assets and chains.",
            "volatilityExample": "Increased granularity of historical data during volatile periods requires 100,000 compressions and archives per second.",
            "assumptions": "Measures the frequency of managing and updating historical loan data.\nAssumes basic historical data management for 100M users, with capacity for increased detail during significant market events.\nScales logarithmically with the number of agents due to optimizations and compression techniques in data management systems at scale."
          }
        ],
        "explanation": "Loan position tracking DA requirements increase due to:\n• More frequent recalculation of loan health metrics\n• Increased loan origination and closure activities during market events\n• Need for more detailed historical data for risk assessment\n• Real-time updates of user dashboards and risk management systems"
      }
    ]
  },
  "cdpAndStablecoin": {
    "name": "CDPs and Stablecoins",
    "explanation": "DA requirements for CDP and stablecoin systems are driven by collateral ratio management, stablecoin minting/burning activities, and complex governance decisions. Extreme market movements and large-scale user actions can cause system-wide DA spikes.",
    "metrics": [
      {
        "name": "Collateral Ratio Management",
        "ongoing": 181500,
        "volatility": 4335000,
        "subMetrics": [
          {
            "name": "Collateral Price Oracles",
            "ongoing": 45000,
            "volatility": 2250000,
            "ongoingExample": "Collateral prices are updated 150,000 times per second from multiple oracles.\nEach price update is 300 bytes, accounting for more comprehensive price data across multiple assets and chains.",
            "volatilityExample": "Oracle updates occur 7,500,000 times per second during high volatility.",
            "assumptions": "Measures the frequency and size of price updates from oracles.\nAssumes integration with a few reliable price oracles, suitable for managing CDPs of 100M users.\nScales superlinearly due to increased complexity and the need for frequent updates as more agents participate, with optimizations at scale."
          },
          {
            "name": "CDP Health Monitoring",
            "ongoing": 90000,
            "volatility": 900000,
            "ongoingExample": "CDP health is recalculated 300,000 times per second for all positions.\nEach health monitoring update is 300 bytes.",
            "volatilityExample": "Continuous real-time monitoring results in 3,000,000 calculations per second of all CDPs during market turbulence.",
            "assumptions": "Measures the frequency of monitoring the health/status of CDPs.\nAssumes regular health checks for CDPs owned by 100M users, with capacity for more frequent updates when needed.\nScales superlinearly due to increased interactions and monitoring complexity with a larger number of agents, but with optimizations at scale."
          },
          {
            "name": "Liquidation Engine",
            "ongoing": 36000,
            "volatility": 360000,
            "ongoingExample": "Liquidation engine checks for undercollateralized CDPs 80,000 times per second.\nEach liquidation action is 450 bytes, accounting for more complex liquidation processes in a multi-asset, multi-chain environment.",
            "volatilityExample": "Liquidation engine runs continuously, processing 800,000 checks per second.",
            "assumptions": "Measures the frequency of liquidation actions when CDPs fall below the required collateral ratio.\nAssumes a basic liquidation engine capable of managing CDPs for 100M users, with some parallel processing capability.\nScales exponentially as more CDPs fall below the required collateral ratio, triggering liquidations, but with slight optimizations at scale."
          },
          {
            "name": "Collateral Ratio Adjustments",
            "ongoing": 10500,
            "volatility": 1050000,
            "ongoingExample": "Collateral ratios are adjusted 35,000 times per second based on market conditions.\nEach adjustment remains at 300 bytes.",
            "volatilityExample": "Rapid market changes require 3,500,000 collateral ratio adjustments per second.",
            "assumptions": "Measures the frequency of manual or automatic adjustments to collateral ratios.\nAssumes occasional collateral ratio adjustments for CDPs owned by 100M users.\nScales superlinearly as the system requires more frequent adjustments with a higher number of participants, but with optimizations at scale."
          }
        ],
        "explanation": "Collateral ratio management DA increases due to:\n• More frequent and precise oracle price updates\n• Continuous recalculation of CDP health metrics\n• Increased liquidation events requiring immediate action\n• Need for real-time global state updates across the network"
      },
      {
        "name": "Stablecoin Minting/Burning",
        "ongoing": 531350,
        "volatility": 10410500,
        "subMetrics": [
          {
            "name": "Minting Operations",
            "ongoing": 6750,
            "volatility": 675000,
            "ongoingExample": "Users mint new stablecoins 15,000 times per second.\nEach minting operation is 450 bytes, accounting for complex minting processes in a multi-asset, multi-chain environment.",
            "volatilityExample": "Surge in minting results in 1,500,000 minting operations per second as users seek stable assets during market downturns.",
            "assumptions": "Measures the frequency of stablecoin minting operations.\nAssumes moderate minting activity from 100M users, with capacity for increased demand during market stress.\nScales superlinearly as the number of minting operations increases with more participants, but with optimizations at scale."
          },
          {
            "name": "Burning Operations",
            "ongoing": 6750,
            "volatility": 6750000,
            "ongoingExample": "Stablecoin burning occurs 15,000 times per second for CDP ratio management.\nEach burning operation is 450 bytes, accounting for more complex burning processes in a multi-asset, multi-chain environment.",
            "volatilityExample": "Mass burning events during deleveraging or confidence loss scenarios lead to 1,500,000 burning operations per second.",
            "assumptions": "Measures the frequency of stablecoin burning operations.\nAssumes occasional burning operations by CDP owners among the 100M users, with potential for coordinated actions during extreme events.\nScales superlinearly as the number of burning operations increases with more participants, but with optimizations at scale."
          },
          {
            "name": "Supply Management",
            "ongoing": 22000,
            "volatility": 660000,
            "ongoingExample": "Total supply is recalculated and published 40,000 times per second.\nEach supply management adjustment is 550 bytes, accounting for comprehensive supply management across multiple assets and chains.",
            "volatilityExample": "Real-time supply updates during high minting/burning activity result in 1,200,000 recalculations per second.",
            "assumptions": "Measures the frequency of adjustments to the overall stablecoin supply to maintain peg stability.\nAssumes a basic supply management system capable of handling the minting and burning activity of 100M users.\nScales exponentially as the frequency of supply adjustments increases with more participants to maintain stability, but with slight optimizations at scale."
          },
          {
            "name": "Transaction Verification",
            "ongoing": 455000,
            "volatility": 1820000,
            "ongoingExample": "Transactions are verified at a rate of 350,000 per second under normal conditions.\nEach transaction verification remains at 1300 bytes.",
            "volatilityExample": "High transaction volume requires verification of 1,400,000 transactions per second to prevent backlogs.",
            "assumptions": "Measures the verification of transactions related to minting and burning operations.\nAssumes standard verification processes suitable for 100M users.\nScales superlinearly due to the need for frequent verifications as the number of transactions grows, but with optimizations at scale."
          }
        ],
        "explanation": "Stablecoin minting/burning DA spikes due to:\n• Increased user activity in creating or closing CDPs\n• Rapid changes in stablecoin supply requiring system-wide updates\n• More frequent checks and adjustments for maintaining the peg\n• Need for real-time tracking of global debt ceiling and individual user limits"
      }
    ]
  },
  "crossChainOperations": {
    "name": "Cross-Chain Operations",
    "explanation": "DA requirements for cross-chain operations are influenced by asset transfers between chains, state synchronization challenges, and the complexity of interoperability protocols. Coordinated cross-chain activities and security incidents can lead to significant DA demand surges.",
    "metrics": [
      {
        "name": "Asset Transfers",
        "ongoing": 264750,
        "volatility": 5175000,
        "subMetrics": [
          {
            "name": "Transaction Verification",
            "ongoing": 140000,
            "volatility": 1400000,
            "ongoingExample": "Cross-chain transactions are verified 400,000 times per second on average.\nEach transaction verification is 350 bytes, accounting for more complex cross-chain verifications.",
            "volatilityExample": "Verification frequency increases to 4,000,000 times per second during high-volume periods.",
            "assumptions": "Measures the verification of transactions related to cross-chain asset transfers.\nAssumes occasional cross-chain transactions from the 100M users, with capacity for increased frequency during high activity periods.\nScales superlinearly due to the increased number of transactions and verifications required as more agents participate, but with optimizations at scale."
          },
          {
            "name": "Liquidity Management",
            "ongoing": 67500,
            "volatility": 1350000,
            "ongoingExample": "Liquidity pools for cross-chain assets are rebalanced 150,000 times per second.\nEach liquidity management action is 450 bytes, accounting for more comprehensive liquidity management across multiple chains.",
            "volatilityExample": "Continuous rebalancing during periods of high transfer volume results in 3,000,000 rebalances per second.",
            "assumptions": "Measures the management of liquidity across chains to ensure smooth transfers.\nAssumes moderate-sized liquidity pools suitable for cross-chain activity of 100M users, with adaptability for volume spikes.\nScales exponentially as the complexity of managing liquidity across chains increases with more participants, but with slight optimizations at scale."
          },
          {
            "name": "Fee Calculation",
            "ongoing": 37500,
            "volatility": 375000,
            "ongoingExample": "Transfer fees are recalculated 150,000 times per second based on network conditions.\nEach fee calculation remains at 250 bytes.",
            "volatilityExample": "Real-time fee adjustments during congestion or attack scenarios lead to 1,500,000 recalculations per second.",
            "assumptions": "Measures the calculation of fees for cross-chain transactions.\nAssumes a basic fee calculation system capable of handling the cross-chain transaction volume from 100M users.\nScales superlinearly with the number of transactions requiring fee calculations, but with optimizations at scale."
          },
          {
            "name": "Transaction Finality Confirmation",
            "ongoing": 20000,
            "volatility": 2000000,
            "ongoingExample": "Cross-chain transaction finality is confirmed 80,000 times per second.\nEach finality confirmation is 250 bytes, accounting for more comprehensive confirmation data.",
            "volatilityExample": "Finality confirmation rate increases to 8,000,000 times per second during high-activity periods.",
            "assumptions": "Measures the confirmation that cross-chain transactions have reached finality.\nAssumes standard finality confirmation processes for cross-chain transactions involving 100M users.\nScales superlinearly as more transactions require finality confirmations, but with optimizations at scale."
          }
        ],
        "explanation": "Asset transfer DA increases due to:\n• Higher frequency of cross-chain transaction verifications\n• Rapid updates to liquidity pools across multiple chains\n• More complex fee calculations considering multi-chain conditions\n• Need for real-time tracking of in-flight transactions across chains"
      },
      {
        "name": "State Synchronization",
        "ongoing": 299000,
        "volatility": 7152000,
        "subMetrics": [
          {
            "name": "Block Header Relay",
            "ongoing": 96000,
            "volatility": 960000,
            "ongoingExample": "Block headers are relayed between chains 80,000 times per second.\nEach block header relay is 1,200 bytes, accounting for more comprehensive block headers.",
            "volatilityExample": "Header relay frequency increases to 800,000 times per second during high-activity periods.",
            "assumptions": "Measures the frequency and size of block header relays between chains.\nAssumes regular block header relay suitable for the cross-chain activity level of 100M users, with ability to increase frequency when needed.\nScales exponentially as the number of relays increases with more participants, but with slight optimizations at scale."
          },
          {
            "name": "Merkle Proof Verification",
            "ongoing": 75000,
            "volatility": 750000,
            "ongoingExample": "Merkle proofs for cross-chain data are verified 150,000 times per second.\nEach Merkle proof verification is 500 bytes.",
            "volatilityExample": "Continuous proof verification during large-scale cross-chain operations leads to 1,500,000 verifications per second.",
            "assumptions": "Measures the verification of Merkle proofs for cross-chain transactions.\nAssumes periodic Merkle proof verifications for the expected cross-chain data volume from 100M users, with capacity for continuous verification during peak times.\nScales superlinearly with the number of transactions requiring verification, but with optimizations at scale."
          },
          {
            "name": "Consensus Mechanism Updates",
            "ongoing": 72000,
            "volatility": 5400000,
            "ongoingExample": "Validator set changes are propagated across chains 40,000 times per second.\nEach consensus update is 1,800 bytes, accounting for more complex consensus updates across multiple chains.",
            "volatilityExample": "Rapid validator set updates during network attacks or failures result in 3,000,000 updates per second.",
            "assumptions": "Measures the updates to the consensus mechanism across chains.\nAssumes a basic consensus mechanism with infrequent updates, suitable for managing cross-chain operations for 100M users.\nScales exponentially due to the need for frequent updates to maintain consensus across chains, but with slight optimizations at scale."
          },
          {
            "name": "State Commitments",
            "ongoing": 56000,
            "volatility": 560000,
            "ongoingExample": "State commitments are made 80,000 times per second to ensure consistency.\nEach state commitment is 700 bytes, accounting for comprehensive state commitments across multiple chains.",
            "volatilityExample": "Commitment frequency increases to 800,000 times per second during high cross-chain activity.",
            "assumptions": "Measures the frequency of state commitments to ensure consistency across chains.\nAssumes regular state commitment processes suitable for managing cross-chain consistency for 100M users.\nScales superlinearly as the complexity of maintaining state consistency increases, but with optimizations at scale."
          }
        ],
        "explanation": "State synchronization DA spikes due to:\n• Increased frequency of block header relays between chains\n• More complex and frequent Merkle proof verifications\n• Rapid propagation of consensus mechanism updates across chains\n• Need for maintaining consistent state across multiple blockchain networks"
      },
      {
        "name": "Interoperability Protocol Management",
        "ongoing": 193000,
        "volatility": 19300000,
        "subMetrics": [
          {
            "name": "Protocol Version Control",
            "ongoing": 100,
            "volatility": 10000,
            "ongoingExample": "Interoperability protocol versions are checked 100 times per second across all integrated chains.\nEach protocol version update is 1,000 bytes, accounting for more comprehensive version control data.",
            "volatilityExample": "Real-time version checks and updates during critical protocol upgrades result in 10,000 checks per second.",
            "assumptions": "Measures the frequency of updates and management of protocol versions across chains.\nAssumes basic version control mechanisms suitable for managing interoperability for 100M users across a limited number of integrated chains.\nScales logarithmically as the number of agents increases, reflecting optimizations and less frequent updates relative to the number of agents at scale."
          },
          {
            "name": "Cross-Chain Contract Calls",
            "ongoing": 120000,
            "volatility": 12000000,
            "ongoingExample": "Cross-chain smart contract calls are processed 80,000 times per second.\nEach cross-chain contract call is 1,500 bytes, accounting for more complex cross-chain calls.",
            "volatilityExample": "Continuous processing of contract calls during multi-chain DApp events results in 8,000,000 calls per second.",
            "assumptions": "Measures the frequency and size of contract calls between chains.\nAssumes occasional cross-chain contract calls from the 100M users, with capacity to handle increased frequency during popular DApp events.\nScales exponentially as the number of contract calls increases with more participants, but with slight optimizations at scale."
          },
          {
            "name": "Bridging Security Monitoring",
            "ongoing": 72900,
            "volatility": 7290000,
            "ongoingExample": "Security audits of bridge contracts are performed 60,750 times per second.\nEach security monitoring event is 1,200 bytes, accounting for more comprehensive security monitoring across multiple chains and bridges.",
            "volatilityExample": "Continuous monitoring and real-time alerts during suspected bridge exploits lead to 6,075,000 audits per second.",
            "assumptions": "Measures the monitoring and management of security for cross-chain bridges.\nAssumes basic security monitoring for cross-chain bridges, suitable for the activity level of 100M users, with enhanced monitoring capabilities during security events.\nScales superlinearly as the complexity of security monitoring increases with more participants, but with optimizations at scale."
          }
        ],
        "explanation": "Interoperability protocol management DA requirements increase due to:\n• Need for consistent protocol versions across multiple chains\n• Increased complexity and frequency of cross-chain contract calls\n• Enhanced security monitoring of bridge contracts and transactions\n• Rapid response mechanisms for cross-chain security incidents"
      }
    ]
  }
}